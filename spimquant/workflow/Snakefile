import os

from zarrnii import ZarrNii
from snakemake.utils import format
from snakebids import bids, generate_inputs, get_wildcard_constraints, set_bids_spec

set_bids_spec("v0_11_0")


configfile: "config/snakebids.yml"


# use expandvars so we can use e.g. '$SLURM_TMPDIR'
root = os.path.expandvars(config["root"])
work = os.path.expandvars(config["work"]) if config["work"] is not None else root

if not config["register_to_mri"]:
    del config["pybids_inputs"]["T2w"]

# Get input wildcards
inputs = generate_inputs(
    bids_dir=config["bids_dir"],
    pybids_inputs=config["pybids_inputs"],
    pybidsdb_dir=config.get("pybidsdb_dir"),
    pybidsdb_reset=config.get("pybidsdb_reset"),
    derivatives=config.get("derivatives", None),
    participant_label=config.get("participant_label", None),
    exclude_participant_label=config.get("exclude_participant_label", None),
    validate=not config.get("plugins.validator.skip", False),
)


# get stains from first subject (lazy - should use the correct stain for each subject, when defining target rules)
#  to do this, would need to get the channel names in the function that gets the target rules
stains = ZarrNii.from_ome_zarr(inputs["spim"].expand()[0]).list_channels()
stain_for_reg = None
for stain in config["stains_for_reg"]:
    if stain in stains:
        stain_for_reg = stain
        break

if stain_for_reg == None:
    raise ValueError(
        "a stain for registration was not found in the first OME zarr file"
    )


stains_for_seg = list(set(config["stains_for_seg"]).intersection(set(stains)))

# atlas segmentations to use
all_atlas_segs = config["templates"][config["template"]]["atlases"].keys()

if config["atlas_segs"] == None:
    atlas_segs = all_atlas_segs
else:
    atlas_segs = []
    for seg in config["atlas_segs"]:
        if seg not in all_atlas_segs:
            raise ValueError(
                f"Chosen segmentation {seg} was not found in the template {config['template']}"
            )
        else:
            atlas_segs.append(seg)

# atlas segmentations to use for patches (defaults to roi22)
patch_atlas_segs = []
for seg in config["patch_atlas_segs"]:
    if seg not in all_atlas_segs:
        raise ValueError(
            f"Chosen patch segmentation {seg} was not found in the template {config['template']}"
        )
    else:
        patch_atlas_segs.append(seg)


wildcard_constraints:
    stain="[a-zA-Z0-9]+",


rule all_templatereg_deform_zooms:
    input:
        spim_zoomed=inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                desc="deform",
                space="{template}",
                stain="{stain}",
                res="{res}um",
                suffix="SPIM.nii",
                **inputs["spim"].wildcards,
            ),
            template=config["template"],
            stain=stains,
            res=config["templatereg"]["zooms"],
        ),


rule all_templatereg_deform:
    input:
        spim=inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                desc="deform",
                space="{template}",
                stain="{stain}",
                suffix="SPIM.nii",
                **inputs["spim"].wildcards,
            ),
            template=config["template"],
            stain=stains,
        ),


rule all_templatereg_lbl:
    input:
        dseg=inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                desc="resampled",
                from_="{template}",
                suffix="dseg.ome.zarr.zip",
                **inputs["spim"].wildcards,
            ),
            template=config["template"],
        ),


rule all_fieldfrac_tune:
    input:
        inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                stain="{stain}",
                level="{level}",
                desc="otsu+k{k}i{i}",
                suffix="fieldfrac.nii",
                **inputs["spim"].wildcards,
            ),
            stain=stains_for_seg,
            level=config["registration_level"],
            k=4,
            i=range(4),
        ),


rule all_segment:
    input:
        inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                seg="{seg}",
                space="{template}",
                stain="{stain}",
                desc="{desc}",
                suffix="{suffix}.nii",
                **inputs["spim"].wildcards,
            ),
            stain=stains_for_seg,
            seg=atlas_segs,
            desc=config["seg_method"],
            template=config["template"],
            suffix=config["seg_metrics"],
        ),
        inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                seg="{seg}",
                space="{template}",
                desc="{desc}",
                suffix="{suffix}.nii",
                **inputs["spim"].wildcards,
            ),
            stain=stains_for_seg,
            seg=atlas_segs,
            desc=config["seg_method"],
            template=config["template"],
            suffix=config["coloc_seg_metrics"].keys(),
        ),
        inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                stain="{stain}",
                level="{level}",
                space="{template}",
                suffix="SPIM.nii",
                **inputs["spim"].wildcards,
            ),
            stain=stains_for_seg + [stain_for_reg],
            level=config["registration_level"],
            template=config["template"],
        ),
        inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                stain="{stain}",
                level="{level}",
                desc="{desc}",
                space="{template}",
                suffix="fieldfrac.nii",
                **inputs["spim"].wildcards,
            ),
            stain=stains_for_seg,
            level=config["registration_level"],
            desc=config["seg_method"],
            template=config["template"],
        ),
        inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                stain="{stain}",
                seg="{seg}",
                desc="deform",
                level="{level}",
                from_="{template}",
                suffix="dseg.{ext}",
                **inputs["spim"].wildcards,
            ),
            stain=stains_for_seg,
            level=config["registration_level"],
            seg=atlas_segs,
            template=config["template"],
            ext=["tsv", "itksnap.txt"],
        ),
        inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                stain="{stain}",
                level="{level}",
                desc="{desc}",
                suffix="counts.nii",
                **inputs["spim"].wildcards,
            ),
            stain=stains_for_seg,
            level=config["registration_level"],
            desc=config["seg_method"],
        ),
        inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                stain="{stain}",
                space="{template}",
                desc="{desc}",
                suffix="counts.nii",
                **inputs["spim"].wildcards,
            ),
            stain=stains_for_seg,
            template=config["template"],
            desc=config["seg_method"],
        ),
        inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                desc="{desc}",
                space="{template}",
                suffix="coloccounts.nii",
                **inputs["spim"].wildcards,
            ),
            desc=config["seg_method"],
            template=config["template"],
        ),


rule all_mri_reg:
    input:
        inputs["spim"].expand(
            bids(
                root=root,
                datatype="anat",
                space="{template}",
                desc="N4",
                suffix="T2w.nii.gz",
                **inputs["spim"].wildcards,
            ),
            template=config["template"],
        ),


rule all_spim_patches:
    input:
        inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                stain="{stain}",
                seg="{seg}",
                from_="{template}",
                level="{level}",
                desc="{desc}",
                suffix="SPIM.patches",
                **inputs["spim"].wildcards,
            ),
            stain=stains_for_seg,
            seg=patch_atlas_segs,
            template=config["template"],
            level=config["segmentation_level"],
            desc=["raw", "corrected" + config["correction_method"]],
        ),
        inputs["spim"].expand(
            bids(
                root=root,
                datatype="micr",
                stain="{stain}",
                seg="{seg}",
                from_="{template}",
                level="{level}",
                desc="{desc}",
                suffix="mask.patches",
                **inputs["spim"].wildcards,
            ),
            stain=stains_for_seg,
            seg=patch_atlas_segs,
            template=config["template"],
            desc=config["seg_method"],
            level=config["segmentation_level"],
        ),


rule all:
    default_target: True
    input:
        rules.all_segment.input,
        rules.all_spim_patches.input,
        rules.all_mri_reg.input if config["register_to_mri"] else [],


include: "rules/common.smk"
include: "rules/import.smk"
include: "rules/masking.smk"
include: "rules/templatereg.smk"
include: "rules/segmentation.smk"
include: "rules/patches.smk"


if config["register_to_mri"]:

    include: "rules/preproc_mri.smk"
